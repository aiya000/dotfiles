"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" nazo

onoremap <silent> q
\      :for i in range(v:count1)
\ <Bar>   call search('.\&\(\k\<Bar>\_s\)\@!', 'W')
\ <Bar> endfor<CR>

set indentexpr&  " &...?


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" Note


NeoBundle 'sorah/unite-ghq'

set comments-=s1:/*,mb:*,ex:*/ " /* Make C-style comments
set comments+=s:/*,mb:\ *,ex:\ */ " * wrap like this
set comments+=fb:*  " */


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"



NeoBundle "osyo-manga/vim-watchdogs"
NeoBundle "motemen/vim-guess-abbrev"
NeoBundle 'kana/vim-fakeclip'
NeoBundle 'gcmt/wildfire.vim'
NeoBundle "syui/airsave.vim"
NeoBundle 'mileszs/ack.vim'
NeoBundle 'motemen/vim-help-random'
NeoBundle 'sgur/unite-qf'
NeoBundle 'thinca/vim-unite-history'
NeoBundle 'sgur/unite-git_grep'
NeoBundle 'thinca/vim-showtime'
" 行末の半角スペースを可視化(うまく動かない？)
NeoBundle 'bronson/vim-trailing-whitespace'
" less用のsyntaxハイライト
NeoBundle 'KohPoll/vim-less'


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" mtth


set diffopt=filler,vertical
set eadirection=hor " only resize automatically horizontally (cf. ``equalalways`` option)
set nostartofline " keeps cursor on current column for movements like H, M, ...
set shellredir=>%s\ 2>&1 " otherwise syntastic isn't able to pick up checker versions
set comments-=:% " these shouldn't be considered comments by default
set formatlistpat=^\\s*\\(\\d\\(\\d\\ze\\d*[\\]:.)}]\\\|[\\]:.)}]\\ze\\)\\\|:[^:]\\ze[^:]*:\\\|[*+-]\\)\\s
if v:version >=# 704
  set formatoptions=rqnlj                                                   " only manual formatting by default
else
  set formatoptions=rqnl                                                    " j option not supported before 7.4
endif
let &dictionary = '/usr/share/dict/words,'                                  " files where to load word for dictionary
let &dictionary .= g:runtimepath . '/spell/custom.utf-8.add'                " completion for use with <c-x><c-k>


haya14busa   : visual-star案件だ  03/08 00:10
" enable search for selected text, forwards (*) or backwards (#)
xnoremap <silent> * :<c-u>
  \let old_reg=getreg('"')<bar>let old_regtype=getregtype('"')<cr>
  \gvy/<c-r>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<cr><cr>
  \:call setreg('"', old_reg, old_regtype)<cr>
xnoremap <silent> # :<c-u>
  \let old_reg=getreg('"')<bar>let old_regtype=getregtype('"')<cr>
  \gvy?<c-r>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<cr><cr>
  \:call setreg('"', old_reg, old_regtype)<cr>

" open .vimrc (following potential symbolic link)
nnoremap <leader>ve :tabnew <c-r>=resolve(expand($MYVIMRC))<cr><cr>:help<cr><c-w>L:vertical resize 80<cr>:set winfixwidth<cr><c-w>h
"source .vimrc (and rerun any filetype settings)
nnoremap <leader>vs :source $MYVIMRC<cr>:filetype detect<cr>


" smart indentation
inoremap <expr> <s-tab> <SID>smart_tab()
function! s:smart_tab() "{{{
  " fills in line with character before cursor until one of the following
  " * matches indent of characters preceded by two or more whitespace characters
  "   in the first non-empty line above
  " * texwidth
  " * next tabstop
  " if the current line is empty, the fill character will be a single space
  let [buf_name, line_number, col_number, off_number] = getpos('.')
  let cur_line = getline(line_number)
  if strlen(cur_line)
    let fill_char = cur_line[col('.') - 2]
  else
    let fill_char = ' '
  endif
  let line_content = ''
  while !strlen(line_content) && line_number >=# 1
    let line_number -= 1
    let line_content = getline(line_number)
  endwhile
  let line_content = line_content[col('.') - 1:]
  let offset = match(line_content, '\s\s\zs\S\|$')
  if offset ># 0
    return repeat(fill_char, offset)
  elseif &textwidth && col_number <=# &textwidth
    return repeat(fill_char, &textwidth - col_number + 1)
  else
    return repeat(fill_char, &tabstop - (col_number - 1) % &tabstop)
  endif
endfunction "}}}
" expand inline parenthesis arguments to multiline
nnoremap gJ 0f(a<cr><esc>f)i<cr><esc>kI<tab><esc>0dw:s/\v,\s+/,\r/g<cr>``<c-v>``I<c-r>"<esc>``A



"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" hotchpotch

Bundle 'ciaranm/detectindent'
Bundle 'L9'
Bundle 'rizzatti/funcoo.vim'
Bundle 'rizzatti/dash.vim'

" We know xterm-debian is a color terminal
if &term =~ "xterm-debian" || &term =~ "xterm-xfree86" || &term =~ "xterm-256color"
 set t_Co=16
 set t_Sf=[3%dm
 set t_Sb=[4%dm
endif

if &term =~ "screen"
  " screen Buffer 切り替えで screen にファイル名を表示
  autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | silent! exe '!echo -n "kv:%\\"' | endif
  autocmd VimLeave * silent! exe '!echo -n "kvim\\"'
endif

" command line で command window 開く
set cedit=<C-O>

" str2numchar.vim
" 範囲選択してる文字列を変換
vnoremap <silent> sn :Stn2NumChar<CR> " あ => &#12354;
vnoremap <silent> sh :Str2HexLiteral<CR> " あ => \\xE3\\x81\\x82

" ウィンドウの高さを選択範囲と同じになるよう調整
vnoremap <silent> _ <Esc>`<zt:execute (line("'>") - line("'<") + 1) 'wincmd' '_'<Return>

++enc

" yanktmp.vim
noremap <silent> sy :call YanktmpYank()<CR>
noremap <silent> sp :call YanktmpPaste_p()<CR>

set nofsync
set grepprg=internal

" 検索レジストリに入ってる文字で現在のファイルを検索し、quickfix で開く
nnoremap <unique> g/ :exec ':vimgrep /' . getreg('/') . '/j %\|cwin'<CR>
" G/ ではすべてのバッファ
" nnoremap <unique> G/ :silent exec ':cexpr "" \| :bufdo vimgrepadd /' . getreg('/') . '/j %'<CR>\|:silent cwin<CR>

" バッファから検索
function! Bgrep(word)
  cexpr '' " quickfix を空に
  silent exec ':bufdo | try | vimgrepadd ' . a:word . ' % | catch | endtry'
  silent cwin
endfunction
command! -nargs=1 Bgrep :call Bgrep(<f-args>)

" 引数の文字列を、ディレクトリ配下から再帰的に検索
function! Findgrep(arg)
  let findgrep_cmd = 'find . -type f ! -regex ".*\.svn.*" ! -regex ".*\.git.*" ! -regex ".*\.sw.*" ! -regex ".*tags" -print0 |xargs -0 grep -n '
  cgetexpr system(findgrep_cmd . a:arg)
  silent cwin
endfunction
command! -nargs=1 Findgrep :call Findgrep(<f-args>)

" changelog
let g:changelog_username = "Yuichi Tateno"
let g:changelog_dateformat = '== %Y-%m-%d'
let g:changelog_new_entry_format= '  * %c'

" ack.vim 
let g:AckAllFiles=0

" QuickFix のサイズ調整,自動で抜ける 
function! s:autoCloseQuickFix()
  let qllen = min([10, len(getqflist())])
  cclose
  if qllen
    execute 'cw' . qllen
    normal <C-W><C-W>
  endif
  redraw
endfunction
autocmd QuickFixCmdPost * :call s:autoCloseQuickFix()
" quickfix を閉じる
nnoremap <unique> ec :cclose<CR>

" jptemplate.vim
let g:jpTemplateKey = '<Tab>'

" {{{ QFixHowm.vim
let QFixHowm_Key = 'g'
if has('win32')
  let howm_dir             = 'c:/dropbox/My Dropbox/howm'
  let QFixHowm_MruFile     = 'c:/dropbox/My Dropbox/howm/.howm-mru'
else
  let howm_dir             = '~/Dropbox/howm'
  let QFixHowm_MruFile     = '~/Dropbox/howm/.howm-mru'
end
let howm_filename        = '%Y/%m/%Y-%m-%d-%H%M%S.howm'
let howm_fileencoding    = 'utf-8'
let howm_fileformat      = 'unix'
let QFixHowm_MruFileMax = 50
let QFixHowm_Title = '='
" let disable_MyQFix = 1

"タイトルに何も書かれていない場合、エントリ内から適当な文を探して設定する。
""文字数は半角換算で最大 QFixHowm_Replace_Title_len 文字まで使用する。0なら何もしない。
"let QFixHowm_Replace_Title_Len = 64

"対象になるのは QFixHowm_Replace_Title_Pattern
"の正規表現に一致するタイトルパターン。
""デフォルトでは次の正規表現が設定されている。
"let QFixHowm_Replace_Title_Pattern = '^'.g:QFixHowm_Title.'\s*$'

"新規エントリの際、本文から書き始める。
"let QFixHowm_Cmd_New = "i".QFixHowm_Title." \<CR>\<C-r>=strftime(\"[%Y-%m-%d%H:%M]\")\<CR>\<CR>\<ESC>$"
"",Cで挿入される新規エントリのコマンド
"let QFixHowm_Key_Cmd_C = "o<ESC>".QFixHowm_Cmd_New

" }}}


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" 2015-03-28

" Installation check.
if neobundle#exists_not_installed_bundles()
  echomsg 'Not installed bundles : ' .
          \ string(neobundle#get_not_installed_bundle_names())
  echomsg 'Please execute ":NeoBundleInstall" command.'
              "finish
endif

" すべての数値を10進数と考える"
set nrformats =

"" 終了するときにファイル情報を保存する
autocmd BufWinLeave *? silent mkview
autocmd BufWinEnter *? silent loadview

"" commentを自動で挿入しない
set formatoptions-=r
------------------------------------------------------------------------------------------------------------------------------------------------
cohama        : L456 formatoptions は直でこういう風に書いても ftplugin で無効にされちゃうことがあるんだよなぁ...。  03/28 23:22
                結論 ftplugin が悪い  03/28 23:22
------------------------------------------------------------------------------------------------------------------------------------------------

"" "%"の拡張
runtime macros/matchit.vim
runtime macros/editexisting.vim


" quickrun.vim 用設定
let g:quickrun_config['python.test'] = {'command': 'nosetests', 'exec': ['%c -v %s']}
let g:quickrun_config['python'] = {'command': 'python3'}

let g:quickrun_config['maxima'] = {'command': 'maxima', 'exec': ['%c -b %s']}
" blockdiag
let g:quickrun_config['blockdiag'] = {
            \'command': 'blockdiag',
            \'exec': ['%c -a %s -o %{expand("%:r")}.png', 'display %{expand("%:r")}.png'],
            \'outputter':'message',
            \}

let g:quickrun_config['tex'] = {
            \'command': 'platex',
            \'exec': ['%c %s && dvipdfmx %{expand("%:r").dvi && evince'],
            \'outputter': 'message'
            \}

let g:quickrun_config['plantuml'] = {
            \'command': 'java',
            \'exec': [
                \'%c -jar ~/bin/plantuml.8020.jar %s -tpng',
                \'display %s:p:r.png'
                \],
            \'outputter': 'null'
            \}
------------------------------------------------------------------------------------------------------------------------------------------------
yassu0320     : ちょっとだけblockdiagのplugin宣伝https://bitbucket.org/yassu0320/blockdiagcontrib-tex  03/28 23:45
------------------------------------------------------------------------------------------------------------------------------------------------


"" task
let g:task_suffix = "task"
let g:task_path = "~/Dropbox/task/"
let g:task_date = "%Y/%m/%d(%a) %H:%M"
function! s:task_edit(...) "{{{
    " assume that len(a:000) <= 1
let l:advance = get(a:, 1, '0')
python << EOF
import vim
from datetime import datetime, timedelta

date = datetime.today()
advance_day = int(vim.eval('l:advance'))
date += timedelta(days=advance_day)
task_filename = '%02d' % date.year + '-%02d' % date.month + '-%02d' % date.day
task_filename += '.' + vim.eval('g:task_suffix')
vim.command("execute 'e' g:task_path . '{}'".format(task_filename))
EOF
endfunction
" }}}
command! -nargs=? TEdit call s:task_edit(<f-args>)
command! -nargs=1 TGrep :execute 'vimgrep' <f-args> g:task_path. '/*'

set makeprg=scons


NeoBundle 'yegappan/mru'
NeoBundle 'jlanzarotta/bufexplorer'
NeoBundle 'Yggdroot/indentLine'
NeoBundle 'bronson/vim-trailing-whitespace'
NeoBundle 'plasticboy/vim-markdown'
NeoBundle 'vim-scripts/maxima.vim'
NeoBundle 'mhaig/vim-blockdiag-series'
NeoBundle 'aklt/plantuml-syntax'
NeoBundle 'nicoraffo/conque'
NeoBundle 'rhysd/committia.vim'
NeoBundle 'yassu/todo-env.vim'
NeoBundle 'ngmy/vim-rubocop'


NeoBundle 'xolox/vim-session', {
    \ 'depends': 'xolox/vim-misc'
\}
" 現在のディレクトリ直下の .vimsessions/ を取得 
let s:local_session_directory = xolox#misc#path#merge(getcwd(), '.vimsessions')
" 存在すれば
if isdirectory(s:local_session_directory)
  " session保存ディレクトリをそのディレクトリの設定
  let g:session_directory = s:local_session_directory
  " vimを辞める時に自動保存
  let g:session_autosave = 'yes'
  " 引数なしでvimを起動した時にsession保存ディレクトリのdefault.vimを開く
  let g:session_autoload = 'yes'
else
  let g:session_autosave = 'no'
  let g:session_autoload = 'no'
endif
unlet s:local_session_directory
command! SaveS :SaveSession

autocmd BufNewFile *.rb 0r ~/.vim/templates/rb.tpl


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"

"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" 11  4月 2015

" Load vimrc from current directory and disable unsafe commands in them
set exrc
set secure

" Use UTF-8 without BOM
set encoding=utf-8 nobomb

" =============================================================================
" Terminal Interaction
" =============================================================================

" Prevent Vim from clearing the scrollback buffer
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=

" Clear PAGER if Vim's Man function is needed
let $PAGER=''


" Don't reset cursor to start of line when moving around
set nostartofline

" Do not jump to the matching bracket upon bracket insert (default)
set noshowmatch


set stl+=%{fugitive#statusline()} " git via fugitive.vim
set gdefault   " Use global search by default

" Some file types use real tabs
au FileType {make,gitconfig} set noexpandtab sw=4

" Update syntax highlighting for more lines increased scrolling performance
syntax sync minlines=256

" Don't syntax highlight long lines
set synmaxcol=256


""
"" Smooth Scroll
""

noremap <silent> <c-u> :call smooth_scroll#up(&scroll, 12, 2)<cr>
noremap <silent> <c-d> :call smooth_scroll#down(&scroll, 14, 2)<cr>
noremap <silent> <c-b> :call smooth_scroll#up(&scroll*2, 22, 4)<cr>
noremap <silent> <c-f> :call smooth_scroll#down(&scroll*2, 24, 4)<cr>



"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"
" 25  4月 2015

set nostartofline
set gdefault
set showfulltag

if has('guicolors')
    let &t_8f="\e[38;2;%ld;%ld;%ldm"
    let &t_8b="\e[48;2;%ld;%ld;%ldm"
    set guicolors
endif

colorscheme lucius
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" bar cursor in insert mode
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif


thinca : quickhl.vim ってのがありますよ 04/25 23:23
https://github.com/t9md/vim-quickhl 04/25 23:24

if exists('&cryptmethod')
    set cryptmethod=blowfish
endif

augroup Stdin
	au!
	au StdinReadPost * :set buftype=nofile
augroup END



"-----------
" 2015-07-11
"-----------

" Dont show preview scratch buffers
set completeopt-=preview

if !has("gui_running")
  " Color scheme based on time
  if strftime("%H") < 15
    let g:rehash256 = 1
    let g:airline_theme='tomorrow'
    colorscheme molokai
  elseif strftime("%H") < 20
    let g:airline_theme='tomorrow'
    colorscheme hybrid
  else
    let g:airline_theme='gotham'
    colorscheme gotham
  endif
endif


"-----------
" 2015-07-26
"-----------
" refer, if you think this is useful
  " default config via http://d.hatena.ne.jp/osyo-manga/20120919/1348054752
  let g:quickrun_config = { "{{{
\    '_': {
\      'hook/close_buffer/enable_empty_data': 1
\      , 'hook/inu/enable': 1
\      , 'hook/inu/wait': 20
\      , 'outputter/buffer/split': ':botright 8sp'
\      , 'outputter/error/error': 'quickfix'
\      , 'outputter/error/success': 'buffer'
\      , 'runner': 'vimproc'
\      , 'runner/vimproc/updatetime': 40
\    },
\    'run/vimproc': {
\      'exec': '%s:p:r %a'
\      , 'output_encode': 'utf-8'
\      , 'runner': 'vimproc'
\      , 'outputter': 'buffer'
\    },
\    'run/vimproc/pause': {
\      'exec': '%s:p:r %a && pause'
\      , 'output_encode': 'utf-8'
\      , 'runner': 'shell'
\      , 'outputter': 'buffer'
\    },
\    'run/system': {
\      'exec': '%s:p:r %a'
\      , 'output_encode': 'utf-8'
\      , 'runner': 'system'
\      , 'outputter': 'buffer'
\    },
\    'markdown': {
\      'type': 'markdown/pandoc'
\      , 'cmdopt': '-s'
\      , 'outputter': 'browser'
\    },
\    'cpp': {
\      'command': 'clang++'
\      , 'cmdopt': '-std=c++11 -stdlib=libc++'
\    },
\    'watchdogs_checker/go_build': {
\      'command': 'go'
\      , 'exec': '%c build %s:p'
\      , 'quickfix/errorformat': '%f:%l:%m'
\    },
\    'go/watchdogs_checker': {
\      'type': 'watchdogs_checker/go_build'
\    },
\   'vim/watchdogs_checker': {
\     'type': executable('vint') ? 'watchdogs_checker/vint' : '',
\   },
\   'watchdogs_checker/vint': {
\     'command'   : 'vint',
\     'exec'      : '%c %o %s:p ',
\   },
\   'sh/watchdogs_checker': {
\     'type': executable('shellcheck') ? 'watchdogs_checker/shellcheck' : '',
\   },
\   'ruby/watchdogs_checker': {
\     'type': executable('rubocop') ? 'watchdogs_checker/rubocop' : 'watchdogs_checker/ruby',
\   },
\   'watchdogs_checker/shellcheck': {
\     'command'   : 'shellcheck',
\     'cmdopt': '-f gcc',
\     'exec'      : '%c %o %s:p ',
\   },
\ } "}}}
NeoBundleLazy 'kien/rainbow_parentheses.vim'


"#-=- -=- -=- -=- -=- -=- -=- -=- -=-#"

vim:ft=vim:
