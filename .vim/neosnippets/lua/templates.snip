snippet try_catch
alias try catch
options indent
  local ok, ${3:result} = pcall(${1:func_name}${2:#:, args})
  if not ok then
    ${0:handling}
  end
snippet define_module

alias module
options indent
  local M = {}

  ${0}

  return M

snippet import
alias imp
abbr local ${1:name} = require('${0:module}')
  local ${1:name} = require('${0:module}')

# TODO: 再帰させて、深くpretty-printする
snippet define_print_table
alias define_print_object define_print_dict
options indent
  local function print_table(t)
    print('{')
    for k, v in pairs(t) do
      print('  ' .. k, '=', v .. ',')
    end
    print('}')
  end

snippet print_table
alias prt pt
abbr ${1:module.}print_table(${0:var})
  ${1:module.}print_table(${0:var})

# Example:
# ```lua
# local result = pipe('hello')
#   :map(string.upper)
#   :map(function(s) return s .. '!' end)
#   :get()  -- 'HELLO!'
# ```
# More useful implementation is:
# - ../../../.config/nvim/lua/utils/pipe.lua
# - https://github.com/aiya000/dotfiles/blob/main/.config/nvim/lua/utils/pipe.lua
snippet define_pipe
options indent
  local function pipe(value)
    return {
      value = value,
      let = function(self, f)
        return pipe(f(self.value))
      end,
      get = function(self)
        return self.value
      end
    }
  end

snippet pipe
abbr ${1:module.}pipe(${0:expr})
  ${1:module.}pipe(${0:expr})


# Example:
# ```lua
# local f = compose(
#   string.upper,
#   function(s) return s .. '!' end
# )
# f('hello')  -- 'HELLO!'
# ```
snippet define_compose
options indent
  local function compose(...)
    local fs = {...}
    return function(value)
      for i = 1, #fs do
        value = fs[i](value)
      end
      return value
    end
  end

snippet compose
alias comp
abbr ${1:module.}compose(${0:functions, })
  ${1:module.}compose(${0:functions, })

#---@param text string --テンプレートリテラルっぽい文字列
#---@return string --変数埋め込み済み文字列
#---Example:
#---```lua
#----- 変数の埋め込み
#---local name = 'Alice'
#---local age = 30
#---local msg = s('Hello {name}! Next year you will be {age + 1}.')
#---
#----- （値の埋め込み）
#---s('{10}')      -- '10'
#---s('{5 + 3}')   -- '8'
#---s('{math.pi}') -- '3.1415926535898'
#---s('{"hello"}') -- 'hello'
#---s('{true}')    -- 'true'
#---s('{nil}')     -- 'nil'
#---
#----- 省略記法
#---s'{10}'
#---```
snippet define_s
alias define_template_string
options indent
  local function s(text)
    -- 呼び出し元のローカル変数を取得
    local context = {}
    local level = 2
    local i = 1
    while true do
      local name, value = debug.getlocal(level, i)
      if not name then break end
      if not name:match('^%(') then -- 一時変数を除外
        context[name] = value
      end
      i = i + 1
    end

    -- グローバル変数を取得
    setmetatable(context, { __index = _G })

    return text:gsub('{([^}]+)}', function(expr)
      local f = load('return ' .. expr, nil, nil, context)
      return f and tostring(f()) or '{' .. expr .. '}'
    end)
  end

snippet s
alias template_string
abbr s'${1:text}}'
  s'${1:text}}'

snippet class
alias cla
options indent
  ---@class ${1:ClassName}
  local $1 = {}
  $1.__index = $1

  ---@return $1
  function $1.new(${2:#:construtor_args})
    local self = setmetatable({}, $1)
    self.${3:arg} = $3
    return self
  end

snippet method
alias met
options indent
  function $1:${2:method_name}()
    ${0}
  end

snippet call_lambda
options indent
  (function ${1:f}(${2:#:args})
     ${0}
  end)(${2:#:args});

snippet define_in_source_test_for_neovim
alias in_source_test
options indent
  -- In-source testing
  if vim == nil then
    local Test = require('utils.test')
    local test = Test.test
    local assert_equal = Test.assert_equal

    ${0}
  end

snippet in_source_test_without_helpers
options indent
  -- In-source testing
  if vim == nil then
    ${0}
  end

snippet define_test
options indent
    ---@param description string
    ---@param check fun(): nil
    ---Example:
    ---\`\`\`lua
    ----- No output
    ---test('X should Y', function()
    ---  -- No errors
    ---end);
    ---
    ----- - Failed: X should Y
    -----   X could not Y
    ---test('X should Y', function()
    ---  error('X could not Y')
    ---end);
    ---\`\`\`
    local function test(description, check)
      local ok, maybe_error_message = pcall(check)
      if not ok then
        print('- Failed: ' .. description)
        print('  ' .. maybe_error_message)
      end
    end

snippet define_assert_equal
options indent
    ---@generic T
    ---@param actual T
    ---@param expected T
    ---@return nil --Throws an error message if \`actual\` does not equal \`expected\`
    ---Example:
    ---\`\`\`lua
    ---assert_equal(1 + 1, 2) -- No error
    ---assert_equal(1 + 1, 3) -- Expected: 3, but got: 2
    ---
    ----- - Failed: \`1 + 1\` should be \`3\`
    -----   Expected: 3, but got: 2
    ---test('\`1 + 1\` should be \`3\`', function()
    ---  assert_equal(1 + 1, 3)
    ---end);
    ---\`\`\`
    local function assert_equal(actual, expected)
      if actual ~= expected then
        error(string.format('Expected: %s, but got: %s', tostring(expected), tostring(actual)))
      end
    end

snippet run_test
alias runtest
options indent
  test('${1:tested_function}() should ${2:what_should_be_done}', function()
    ${0}
  end)

snippet todo
abbr print('TODO: Not Implemented Yet (${0:function_name})')
  print('TODO: Not Implemented Yet (${0:function_name})')
