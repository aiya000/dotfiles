snippet try_catch
alias try catch
options indent
  local ok, ${3:result} = pcall(${1:func_name}${2:#:, args})
  if not ok then
    ${0:handling}
  end
snippet define_module

alias module
options indent
  local M = {}

  ${0}

  return M

snippet import
alias imp
abbr local ${1:name} = require('${0:module}')
  local ${1:name} = require('${0:module}')

# TODO: 再帰させて、深くpretty-printする
snippet define_print_table
alias define_print_object define_print_dict
options indent
  local function print_table(t)
    print('{')
    for k, v in pairs(t) do
      print('  ' .. k, '=', v .. ',')
    end
    print('}')
  end


snippet print_table
alias prt pt
abbr ${1:module.}print_table(${0:var})
  ${1:module.}print_table(${0:var})

# Example:
# ```lua
# local result = pipe('hello')
#   :map(string.upper)
#   :map(function(s) return s .. '!' end)
#   :get()  -- 'HELLO!'
# ```
snippet define_pipe
options indent
  local function pipe(value)
    return {
      value = value,
      let = function(self, f)
        return pipe(f(self.value))
      end,
      get = function(self)
        return self.value
      end
    }
  end

snippet pipe
abbr ${1:module.}pipe(${0:expr})
  ${1:module.}pipe(${0:expr})


# Example:
# ```lua
# local f = compose(
#   string.upper,
#   function(s) return s .. '!' end
# )
# f('hello')  -- 'HELLO!'
# ```
snippet define_compose
options indent
  local function compose(...)
    local fs = {...}
    return function(value)
      for i = 1, #fs do
        value = fs[i](value)
      end
      return value
    end
  end

snippet compose
alias comp
abbr ${1:module.}compose(${0:functions, })
  ${1:module.}compose(${0:functions, })

# Example:
# ```lua
# local name = 'Alice'
# local age = 30
# local msg = s('Hello {name}! Next year you'll be {age + 1}.', {
#   name = name,
#   age = age,
# })
# ```
snippet define_s
alias define_template_string
options indent
  local function s(text, env)
    return text:gsub('{([^}]+)}', function(expr)
      local f = load('return'  .. expr, nil, nil, env)
      return f and f() or '{' .. expr .. '}'
    end)
  end

snippet s
alias template_string
abbr ${1:module.}s('${1:text}}')
  ${1:module.}s('${1:text}}')

snippet class
alias cla
options indent
  ---@class ${1:ClassName}
  local $1 = {}
  $1.__index = $1

  ---@return $1
  function $1.new(${2:#:construtor_args})
    local self = setmetatable({}, $1)
    self.${3:arg} = $3
    return self
  end

snippet method
alias met
options indent
  function $1:${2:method_name}()
    ${0}
  end

snippet call_lambda
options indent
  (function ${1:f}(${2:#:args})
     ${0}
  end)(${2:#:args});

snippet define_in_source_test_for_neovim
alias in_source_test
options indent
  -- In-source testing
  if vim == nil then
    ---@param description string
    ---@param check fun(): nil
    ---Example:
    ---\`\`\`lua
    ----- No output
    ---test('X should Y', function()
    ---  -- No errors
    ---end)
    ---
    ----- - Failed: X should Y
    -----   X could not Y
    ---test('X should Y', function()
    ---  error('X could not Y')
    ---end)
    ---\`\`\`
    local function test(description, check)
      local ok, maybe_error_message = pcall(check)
      if not ok then
        print('- Failed: ' .. description)
        print('  ' .. maybe_error_message)
      end
    end

    ---@generic T
    ---@param actual T
    ---@param expected T
    ---@return nil --Throws an error message if \`actual\` does not equal \`expected\`
    ---Example:
    ---\`\`\`lua
    ---assert_equal(1 + 1, 2) -- No error
    ---assert_equal(1 + 1, 3) -- Expected: 3, but got: 2
    ---
    ----- - Failed: \`1 + 1\` should be \`3\`
    -----   Expected: 3, but got: 2
    ---test('\`1 + 1\` should be \`3\`', function()
    ---  assert_equal(1 + 1, 3)
    ---end)
    ---\`\`\`
    local function assert_equal(actual, expected)
      if actual ~= expected then
        error(string.format('Expected: %s, but got: %s', tostring(expected), tostring(actual)))
      end
    end

    ${0}
  end

snippet in_source_test_without_helpers
options indent
  -- In-source testing
  if vim == nil then
    ${0}
  end

snippet define_test
options indent
    ---@param description string
    ---@param check fun(): nil
    ---Example:
    ---\`\`\`lua
    ----- No output
    ---test('X should Y', function()
    ---  -- No errors
    ---end);
    ---
    ----- - Failed: X should Y
    -----   X could not Y
    ---test('X should Y', function()
    ---  error('X could not Y')
    ---end);
    ---\`\`\`
    local function test(description, check)
      local ok, maybe_error_message = pcall(check)
      if not ok then
        print('- Failed: ' .. description)
        print('  ' .. maybe_error_message)
      end
    end

snippet define_assert_equal
options indent
    ---@generic T
    ---@param actual T
    ---@param expected T
    ---@return nil --Throws an error message if \`actual\` does not equal \`expected\`
    ---Example:
    ---\`\`\`lua
    ---assert_equal(1 + 1, 2) -- No error
    ---assert_equal(1 + 1, 3) -- Expected: 3, but got: 2
    ---
    ----- - Failed: \`1 + 1\` should be \`3\`
    -----   Expected: 3, but got: 2
    ---test('\`1 + 1\` should be \`3\`', function()
    ---  assert_equal(1 + 1, 3)
    ---end);
    ---\`\`\`
    local function assert_equal(actual, expected)
      if actual ~= expected then
        error(string.format('Expected: %s, but got: %s', tostring(expected), tostring(actual)))
      end
    end

snippet run_test
alias runtest
options indent
  test('${1:tested_function}() should ${2:what_should_be_done}', function()
    ${0}
  end)

snippet todo
abbr print('TODO: Not Implemented Yet (${0:function_name})')
  print('TODO: Not Implemented Yet (${0:function_name})')
